define getDataExplorerURL as method doing:
	return "http://localhost:8081/index.html"

// don't directly connect Modules to keep them lightweight
// also eliminates any (accidental) cyclical dependency
define Dependency as storable category with attributes name and version
define dependencies as storable Dependency[] attribute

define Module as storable category with attributes name, version, description, image and dependencies

define Thesaurus as storable Module
define Library as storable Module
define Service as storable Module
define WebSite as storable Module
define Script as storable Module

define entryPoint as storable Text attribute
define Batch as storable Module with attribute entryPoint

define module as storable Module attribute

define lastOpened as storable DateTime attribute
define CodingSession as storable category with attributes user, module and lastOpened
define RecentSession as storable CodingSession

define storable as storable Boolean attribute
define Declaration as storable category with attributes name, version, dialect, storable, body and module
define AttributeDeclaration as storable Declaration
define CategoryDeclaration as storable Declaration
define EnumeratedDeclaration as storable Declaration
define MethodDeclaration as storable Declaration with attribute prototype
define TestDeclaration as storable Declaration

define declaration as Declaration attribute

define EditStatus as enumerated Text with symbols:
	CLEAN with "CLEAN" as value
	CREATED with "CREATED" as value
	DELETED with "DELETED" as value 
	DIRTY with "DIRTY" as value

define editStatus as EditStatus attribute with key index

define EditedDeclaration as category with attributes editStatus and declaration

define getRecentModules as method receiving Integer count doing:
	user = getHttpUser
	if user is nothing:
		raise NULL_REFERENCE
	sessions = fetch RecentSession 1 to count where user = user order by lastOpened desc
	return session.module for each session in sessions

define getAllModules as method doing:
	return fetch all Module order by name


define getModuleDescription as method receiving dbId and Boolean register doing:
	user = getHttpUser
	if user is nothing:
		raise NULL_REFERENCE
	module = fetch one Module where dbId = dbId
	if module is nothing:
		raise NULL_REFERENCE
	if register:
		// use this opportunity to keep track of coding sessions
		session = CodingSession with user as user, module as module and now as lastOpened 
		store session
		// use this opportunity to keep track of recent projects
		recent = fetch one mutable RecentSession where user = user and module = module
		if recent is nothing:
			recent = RecentSession with user as user, module as module and now as lastOpened 
		else:
			recent.lastOpened = now 
		store recent
		flush
	return module


define getModuleDeclarations as method receiving name and version doing:
	user = getHttpUser
	if user is nothing:
		raise NULL_REFERENCE
	module = fetch one Module where name = name and version = version
	if module is nothing:
		raise NULL_REFERENCE
	return fetch all Declaration where module = module


define getModuleDeclarations as method receiving dbId doing:
	user = getHttpUser
	if user is nothing:
		raise NULL_REFERENCE
	module = fetch one Module where dbId = dbId
	if module is nothing:
		raise NULL_REFERENCE
	return fetch all Declaration where module = module


define storeDeclarations as method receiving EditedDeclaration[] edited doing:
	deleted = d1.declaration for each d1 in fetch any d from edited where d.editStatus = DELETED
	created = d2.declaration for each d2 in fetch any d from edited where d.editStatus = CREATED
	updated = d3.declaration for each d3 in fetch any d from edited where d.editStatus = DIRTY
	delete deleted and store created, updated 
	flush


define createModule as method receiving Text type, name, description = nothing, image = nothing, Boolean createEntryPoint, entryPoint = nothing doing:
	decl = nothing as Declaration
	// at minimal, all modules depend on Thesaurus
	lib = fetch one Library where name = "Thesaurus"
	deps = [Dependency from lib]
	module = Module with name as name, "1.0.0.0" as version, description as description, image as image and deps as dependencies
	switch on type:
		when "library":
			module = Library from module
		when "service":
			module = Service from module
		when "website":
			module = WebSite from module
		when "script":
			module = Script from module
		when "batch":
			if createEntryPoint:
				entryPoint = "main_" + name
			batch = Batch from module with entryPoint as entryPoint
			decl = createMainMethod with batch as batch
			module = batch
	store decl, module
	flush


define createMainMethod as method receiving Batch batch doing:
	body = "define " + batch.entryPoint + " as method receiving Text{} options doing:\n"
	body = body + "\tprint \"Hello " + batch.name + "\"\n" 
	decl = MethodDeclaration with batch.entryPoint as name, "0.0.0.1" as version, "E" as dialect, "Text{}" as prototype, body as body and batch as module
	return decl 


define deleteModule as method receiving dbId doing:
	module = fetch one Module where dbId = dbId
	if module is nothing:
		raise NULL_REFERENCE
	delarations = fetch all Declaration where module = module
	sessions = fetch all RecentSession where module = module
	delete delarations, sessions, module
	flush


define exportModule as method receiving dbId doing:
	module = fetch one Module where dbId = dbId
	if module is nothing:
		raise NULL_REFERENCE
	type = ""
	if module is a Batch:
		type = "batch"
	else if module is a Script:
		type = "script"
	else if module is a WebSite:
		type = "website"
	else if module is a Service:
		type = "service"
	else if module is a Library:
		type = "library"
	doc = Document
	doc.type = type
	doc.name = module.name
	doc.version = module.version
	doc.description = module.description
	doc.image = module.image
	if module is a Batch:
		doc.entryPoint = module.entryPoint
	declarations = [] as Declaration[]
	fetched = fetch all mutable Declaration where module = module
	for each declaration in fetched:
		declaration.module = Nothing 
		declarations = declarations + [declaration]
	doc.declarations = declarations
	return Blob from doc
